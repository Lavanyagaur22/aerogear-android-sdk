package org.aerogear.mobile.core.reactive;

import android.support.annotation.NonNull;
import android.util.Log;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicReference;

import static org.aerogear.mobile.core.utils.SanityCheck.nonNull;


/**
 * This class represents a request to code that delivers its results via an callback.
 * <p>
 * Calls made to the request happen on the requestOn executor
 * The callback is executed on the requestOnExecutor
 * The responded passed to the call back passes its value to a responder defined with respondWith and
 * on the respondOn executor.
 *
 * @param <T> the type emitted from the underlying call
 */
class AsyncRequest<T> extends AbstractRequest<T> {
    private static final String ERROR_TAG = "UNCAUGHT_EXCEPTION";

    private final VoidReturnWithParam<Responder<T>> source;

    private final AtomicReference<Cleaner> cleanerAtomicReference;
    private final AtomicReference<Canceller> cancellerRef;
    private Thread callableThread = null;

    public AsyncRequest(VoidReturnWithParam<Responder<T>> source) {
        this.source = nonNull(source, "callable");

        this.cleanerAtomicReference = new AtomicReference<>(() -> {
        });
        cancellerRef = new AtomicReference<>(() -> {
            synchronized (source) {
                if (callableThread != null) {
                    callableThread.interrupt();
                }
            }
        });

    }

    public AsyncRequest(VoidReturnWithParam<Responder<T>> source, Cleaner cleanupAction) {
        this.source = source;
        this.cleanerAtomicReference = new AtomicReference<>(cleanupAction);
        cancellerRef = new AtomicReference<>(() -> {
            synchronized (source) {
                if (callableThread != null) {
                    callableThread.interrupt();
                }
            }
        });
    }


    @Override
    Request<T> respondWithActual(AtomicReference<Responder<T>> responderRef) {
        if (responderRef.get() == null) { // responder may have been disconnected.
            return this;
        }

        CaptureResponder<T> captureResponder = new CaptureResponder<>(responderRef);


        try {
            callableThread = Thread.currentThread();
            source.execute(captureResponder);

        } catch (Exception e) {
            captureResponder.exception = e;
        }

        return this;

    }

    @Override
    public void cancel() {
        cancellerRef.get().doCancel();
    }

    @Override
    public Request<T> cancelWith(Canceller canceller) {
        cancellerRef.set(nonNull(canceller, "canceller"));
        return this;
    }

    @Override
    protected Cleaner liftCleanupAction() {
        Cleaner oldCleaner = cleanerAtomicReference.getAndSet(() -> {
        });
        return oldCleaner;
    }

    /**
     * This is a special responder that is passed into a {@link VoidReturnWithParam} that performs
     * most of the usual tasks after a value is calculated.  Since Async task receives this value
     * in a callback, we need to provide a callback to consume this value.
     *
     * @param <T> the type of the value generated by the request
     */
    private class CaptureResponder<T> implements Responder<T> {

        private final AtomicReference<Responder<T>> responderRef;
        T value;
        Exception exception;

        public CaptureResponder(AtomicReference<Responder<T>> responderRef) {
            this.responderRef = responderRef;
        }

        @Override
        public void onResult(T value) {
            this.value = value;
            afterAsyncCalledComplete();
        }

        @Override
        public void onException(Exception exception) {
            this.exception = exception;
            afterAsyncCalledComplete();
        }

        private void afterAsyncCalledComplete() {
            try {
                Responder<T> responder = responderRef.get();
                if (responder == null) {
                    // responder may have been disconnected while the calculation was
                    // performed.
                    return;
                }

                if (exception == null) {
                    responder.onResult(value);
                } else {
                    responder.onException(exception);
                }
            } catch (Throwable responderThrowable) {
                if (responderThrowable instanceof Error) {
                    /*
                     * Applications should not try to handle errors. If a responder threw an error this
                     * means that something fundamental has failed and it should be passed out of the
                     * Reactive system.
                     */
                    throw responderThrowable;
                } else {
                    /*
                     * Responders with uncaught exceptions should not blow up the reactive stack. For
                     * now we will log them, but one day a RxPlugin style mechanism may be appropriate.
                     */
                    Log.e(ERROR_TAG, responderThrowable.getMessage(), responderThrowable);
                }
            } finally {
                synchronized (source) { // We are synchronizing on the callable because we don't want
                    // the thread reference to go null in the cancel method.
                    callableThread = null;
                }
                cleanerAtomicReference.get().cleanup();
            }
        }
    }

}
